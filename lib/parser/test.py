import sys
#from antlr4 import *
# import antlr4
#from .JavaLexer import JavaLexer
#from .JavaParser import JavaParser
#from .JavaListener import JavaListener
import javalang
import re
# from Python2Lexer import Python2Lexer
# from Python2Parser import Python2Parser
# from Python2Listener import Python2Listener

# input_s = """def get_flashed_messages(with_categories=False, category_filter=[]): flashes = _request_ctx_stack.top.flashes if (flashes is None):  _request_ctx_stack.top.flashes = flashes = (session.pop('_flashes') if ('_flashes' in session) else []) if category_filter: flashes = list(filter((lambda f: (f[0] in category_filter)), flashes)) if (not with_categories): return [x[1] for x in flashes] return flashes"""
#line = """package com.hp.hpl.jena.xmloutput.test;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Random; import java.util.Vector; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import com.hp.hpl.jena.rdf.model.Model; import com.hp.hpl.jena.rdf.model.Property; import com.hp.hpl.jena.rdf.model.RDFErrorHandler; import com.hp.hpl.jena.rdf.model.RDFNode; import com.hp.hpl.jena.rdf.model.RDFReader; import com.hp.hpl.jena.rdf.model.RDFWriter; import com.hp.hpl.jena.rdf.model.Resource; import com.hp.hpl.jena.rdf.model.Statement; import com.hp.hpl.jena.rdf.model.StmtIterator; import com.hp.hpl.jena.rdf.model.test.ModelTestBase; import com.hp.hpl.jena.shared.JenaException; import com.hp.hpl.jena.vocabulary.DAML_OIL; import com.hp.hpl.jena.vocabulary.RDFSyntax;   public class testWriterAndReader extends ModelTestBase implements RDFErrorHandler {      private static boolean showProgress = false;      private static int firstTest = 4;      private static int lastTest = 9;      private static int repetitionsJ = 6;      protected static Log logger = LogFactory.getLog(testWriterAndReader.class);      String lang;      String test;      int fileNumber;      int options = 0;      testWriterAndReader(String name, String lang, int fName) {         super(name);         this.lang = lang;         this.fileNumber = fName;     }      testWriterAndReader(String name, String lang, int fName, int options) {         super(name);         this.lang = lang;         this.fileNumber = fName;         this.options = options;     }      public String toString() {         return getName() + " " + lang + " t" + fileNumber + "000.rdf" + (options != 0 ? ("[" + options + "]") : "");     }      static Test suite(String lang) {         return suite(lang, false);     }      public static Test suite() {         return suite("special");     }      private static boolean nBits(int i, int ok[]) {         int cnt = 0;         while (i > 0) {             if ((i & 1) == 1) cnt++;             i >>= 1;         }         for (int j = 0; j < ok.length; j++) if (cnt == ok[j]) return true;         return false;     }      static Test suite(String lang, boolean lots) {         TestSuite langsuite = new TestSuite();         langsuite.setName(lang);         if (lang.equals("special")) {             langsuite.addTest(new TestXMLFeatures("testNoReification", "RDF/XML-ABBREV"));             return langsuite;         }         langsuite.addTest(new testWriterInterface("testWriting", lang));         langsuite.addTest(new testWriterInterface("testLineSeparator", lang));         for (int k = firstTest; k <= lastTest; k++) {             if (lang.indexOf("XML") > 0) {                 langsuite.addTest(new testWriterAndReader("testLongId", lang, k));                 for (int j = 1; j < (lang.equals("RDF/XML-ABBREV") ? (1 << blockRules.length) : 2); j++) {                     if (lots || nBits(j, new int[] { 1, 6, 7 })) langsuite.addTest(new testWriterAndReader("testOptions " + k + " " + j, lang, k, j) {                          public void runTest() throws IOException {                             testOptions();                         }                     });                 }             }         }         if (lang.indexOf("XML") > 0) {             langsuite.addTest(new TestXMLFeatures("testBadURIAsProperty1", lang));             langsuite.addTest(new TestXMLFeatures("testBadURIAsProperty2", lang));             langsuite.addTest(new TestXMLFeatures("testBadProperty1", lang));             langsuite.addTest(new TestXMLFeatures("testLiAsProperty1", lang));             langsuite.addTest(new TestXMLFeatures("testDescriptionAsProperty", lang));             langsuite.addTest(new TestXMLFeatures("testXMLBase", lang));             langsuite.addTest(new TestXMLFeatures("testRelativeAPI", lang));             langsuite.addTest(new TestXMLFeatures("testRelative", lang));             langsuite.addTest(new TestXMLFeatures("testBug696057", lang));             langsuite.addTest(new TestXMLFeatures("testPropertyURI", lang));             langsuite.addTest(new TestXMLFeatures("testUseNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testUseDefaultNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testUseUnusedNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testBadPrefixNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testRDFNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicatePrefixSysPropAndExplicit", lang));             langsuite.addTest(new TestXMLFeatures("testRDFDefaultNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicateNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicatePrefix", lang));             langsuite.addTest(new TestXMLFeatures("testUseNamespaceSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testDefaultNamespaceSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicateNamespaceSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicatePrefixSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testUTF8DeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testUTF16DeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testUTF8DeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testUTF16DeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testISO8859_1_DeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testISO8859_1_DeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testStringDeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testStringDeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testTab", lang));             langsuite.addTest(new TestXMLFeatures("testNoLiteral", lang));             langsuite.addTest(new TestXMLFeatures("testNoTab", lang));             langsuite.addTest(new TestXMLFeatures("testDoubleQuote", lang));             langsuite.addTest(new TestXMLFeatures("testSingleQuote", lang));             langsuite.addTest(new TestXMLFeatures("testNullBaseWithAbbrev", lang));         }         if (lang.equals("RDF/XML-ABBREV")) {             langsuite.addTest(new TestXMLFeatures("testNoPropAttr", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoDamlCollection", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoRdfCollection", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoLi", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoID", lang));             langsuite.addTest(new TestXMLFeatures("testNoID2", lang));             langsuite.addTest(new TestXMLFeatures("testNoResource", lang));             langsuite.addTest(new TestXMLFeatures("testNoReification", lang));             langsuite.addTest(new TestXMLFeatures("testNoPropAttrs", lang));             langsuite.addTest(new TestXMLFeatures("testNoCookUp", lang));             langsuite.addTest(new TestXMLFeatures("testPropAttrs", lang));         }         return langsuite;     }      public void testRandom() throws IOException {         doTest(new String[] {}, new Object[] {});     }      public void testLongId() throws IOException {         doTest(new String[] { "longId" }, new Object[] { new Boolean(true) });     }      static Resource blockRules[] = { RDFSyntax.parseTypeLiteralPropertyElt, RDFSyntax.parseTypeCollectionPropertyElt, RDFSyntax.propertyAttr, RDFSyntax.sectionReification, RDFSyntax.sectionListExpand, RDFSyntax.parseTypeResourcePropertyElt, DAML_OIL.collection };      public void testOptions() throws IOException {         Vector v = new Vector();         for (int i = 0; i < blockRules.length; i++) {             if ((options & (1 << i)) != 0) v.add(blockRules[i]);         }         Resource blocked[] = new Resource[v.size()];         v.copyInto(blocked);         doTest(new String[] { "blockRules" }, new Object[] { blocked });     }      public void doTest(String[] propNames, Object[] propVals) throws IOException {         test(lang, 35, 1, propNames, propVals);     }      static final String baseUris[] = { "http://foo.com/Hello", "http://foo.com/Hello", "http://daml.umbc.edu/ontologies/calendar-ont", "http://www.daml.org/2001/03/daml+oil-ex" };      ByteArrayOutputStream tmpOut;           public void test(String rwLang, int seed, int jjjMax, String[] wopName, Object[] wopVal) throws IOException {         Model m1 = createMemModel();         Model m2 = createMemModel();         test = "testWriterAndReader lang=" + rwLang + " seed=" + seed;         String filebase = "testing/regression/testWriterAndReader/";         if (showProgress) System.out.println("Beginning " + test);         Random random = new Random(seed);         RDFReader rdfRdr = m1.getReader(rwLang);         RDFWriter rdfWtr = m1.getWriter(rwLang);         if (wopName != null) {             for (int i = 0; i < wopName.length; i++) {                 rdfWtr.setProperty(wopName[i], wopVal[i]);             }         }         rdfRdr.setErrorHandler(this);         rdfWtr.setErrorHandler(this);         for (int jjj = 0; jjj < jjjMax; jjj++) {             String fileName = "t" + (fileNumber * 1000) + ".rdf";             m1 = createMemModel();             String baseUriRead;             if (fileNumber < baseUris.length) baseUriRead = baseUris[fileNumber]; else baseUriRead = "http://foo.com/Hello";             InputStream rdr = new FileInputStream(filebase + fileName);             m1.read(rdr, baseUriRead);             rdr.close();             for (int j = 0; j < repetitionsJ; j++) {                 String baseUriWrite = j % 2 == 0 ? baseUriRead : "http://bar.com/irrelevant";                 int cn = (int) m1.size();                 if ((j % 2) == 0 && j > 0) prune(m1, random, 1 + cn / 10);                 if ((j % 2) == 0 && j > 0) expand(m1, random, 1 + cn / 10);                 tmpOut = new ByteArrayOutputStream();                 rdfWtr.write(m1, tmpOut, baseUriWrite);                 tmpOut.flush();                 tmpOut.close();                 m2 = createMemModel();                 InputStream in = new ByteArrayInputStream(tmpOut.toByteArray());                 rdfRdr.read(m2, in, baseUriWrite);                 in.close();                 Model s1 = m1;                 Model s2 = m2;                 assertTrue("Comparison of file written out, and file read in.", s1.isIsomorphicWith(s2));                 tmpOut.reset();                 tmpOut = null;             }             if (showProgress) {                 System.out.print("+");                 System.out.flush();             }         }         if (showProgress) System.out.println("End of " + test);     }      static boolean linuxFileDeleteErrorFlag = false;           private void prune(Model m, Random random, int cnt) {         Statement die[] = new Statement[cnt];         int sz = (int) m.size();         StmtIterator ss = m.listStatements();         try {             for (int i = 0; i < cnt; i++) die[i] = ss.nextStatement();             while (ss.hasNext()) {                 int ix = random.nextInt(sz);                 if (ix < cnt) die[ix] = ss.nextStatement();             }         } finally {             ss.close();         }         for (int i = 0; i < cnt; i++) m.remove(die[i]);     }           private void expand(Model m, Random random, int cnt) {         Resource subject[] = new Resource[cnt];         Property predicate[] = new Property[cnt];         RDFNode object[] = new RDFNode[cnt];         int sz = (int) m.size();         StmtIterator ss = m.listStatements();         try {             for (int i = 0; i < cnt; i++) {                 Statement s = ss.nextStatement();                 subject[i] = s.getSubject();                 predicate[i] = s.getPredicate();                 object[i] = s.getObject();             }             while (ss.hasNext()) {                 Statement s = ss.nextStatement();                 Resource subj = s.getSubject();                 RDFNode obj = s.getObject();                 int ix = random.nextInt(sz);                 if (ix < cnt) subject[ix] = subj;                 ix = random.nextInt(sz);                 if (ix < cnt) object[ix] = subj;                 ix = random.nextInt(sz);                 if (ix < cnt) predicate[ix] = s.getPredicate();                 ix = random.nextInt(sz);                 if (ix < cnt) object[ix] = obj;                 if (obj instanceof Resource) {                     ix = random.nextInt(sz);                     if (ix < cnt) subject[ix] = (Resource) obj;                 }             }         } finally {             ss.close();         }         for (int i = 0; i < cnt; i++) m.add(subject[i], predicate[i], object[i]);     }           public void warning(Exception e) {         System.out.println(new String(tmpOut.toString()));         throw new JenaException(e);     }      public void error(Exception e) {         fail(e.getMessage());     }      public void fatalError(Exception e) {         error(e);         throw new JenaException(e);     } """
#line="""package org.placelab.test;  import java.io.BufferedOutputStream; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.Hashtable; import org.placelab.mapper.JDBMMapper; import org.placelab.mapper.JDBMQuickMapLoader; import org.placelab.mapper.MapLoader; import org.placelab.proxy.HTTPRequest; import org.placelab.proxy.HTTPResponse; import org.placelab.proxy.ProxyServletEngine; import org.placelab.proxy.Servlet; import org.placelab.util.FileSynchronizer; import org.placelab.util.ZipUtil;  public class JDBMQuickMapLoaderTest implements Testable {      private static class FileVend implements Servlet {          private Hashtable files;          public static String SERVLET_PREFIX = "http://placelab.mapload.test/file";          public FileVend(Hashtable files) {             this.files = files;         }          public String getName() {             return "FileVendServlet";         }          public void register() {             ProxyServletEngine.addServlet(SERVLET_PREFIX, this);         }          public HTTPResponse serviceRequest(HTTPRequest req) {             StringBuffer sb = new StringBuffer();             String s = req.url.toString().substring(SERVLET_PREFIX.length());             if (!s.startsWith("/")) {                 return whoops();             }             String f = s.substring(1);             String path = (String) files.get(f);             if (path == null) return whoops();             try {                 return fileResponse(path);             } catch (IOException e) {                 return whoops();             }         }          private HTTPResponse fileResponse(String path) throws IOException {             File file = new File(path);             ByteArrayOutputStream to = new ByteArrayOutputStream();             FileInputStream from = new FileInputStream(file);             ZipUtil.pipeStreams(to, from);             from.close();             return new HTTPResponse(HTTPResponse.RESPONSE_OK, "application/unknown", to.size(), to.toByteArray());         }          private HTTPResponse whoops() {             return new HTTPResponse(HTTPResponse.RESPONSE_NOT_FOUND, "text/plain", "whoops".length(), "whoops".getBytes());         }          public Hashtable injectHeaders(HTTPRequest req) {             return null;         }     }      public String getName() {         return "JDBMQuickMapLoaderTest";     }      public void runTests(TestResult result) throws Throwable {         setup();         String oldPort = System.getProperty("http.proxyPort");         String oldHost = System.getProperty("http.proxyHost");         System.setProperty("http.proxyPort", "2080");         System.setProperty("http.proxyHost", "localhost");         JDBMQuickMapLoader qml = new JDBMQuickMapLoader(FileVend.SERVLET_PREFIX + "/mapper-zip.php", FileVend.SERVLET_PREFIX + "/mapper-md5.php", dPath);         checkCreate(result, qml);         ((JDBMMapper) qml.getMapper()).deleteAll();         StringBuffer sb = new StringBuffer();         sb.append("47.6636333\\t-122.3083683\\tlambda\\t004005b45c85\\n");         sb.append("47.6636333\\t-122.3083683\\tlinksys\\t000c41424432\\n");         InputStream is = new ByteArrayInputStream(sb.toString().getBytes());         qml.loadMap(is);         checkDifferent(result, qml);         checkSame(result, qml);         if (oldPort != null) System.setProperty("http.proxyPort", oldPort);         if (oldHost != null) System.setProperty("http.proxyHost", oldHost);     }      private void checkSame(TestResult result, JDBMQuickMapLoader qml) throws Exception {         result.assertTrue(this, true, qml.doIt(), "qml checkSame: up to date check check");         result.assertTrue(this, 3, ((JDBMMapper) qml.getMapper()).size(), "qml checkSame: Number of items in fresh download check");     }      private void checkCreate(TestResult result, JDBMQuickMapLoader qml) throws Exception {         result.assertTrue(this, false, qml.doIt(), "qml checkCreate: up to date check check");         result.assertTrue(this, 3, ((JDBMMapper) qml.getMapper()).size(), "qml checkCreate: Number of items in fresh download check");     }      private void checkDifferent(TestResult result, JDBMQuickMapLoader qml) throws Exception {         result.assertTrue(this, false, qml.doIt(), "qml checkDifferent: up to date check check");         result.assertTrue(this, 3, ((JDBMMapper) qml.getMapper()).size(), "qml checkDifferent: Number of items in fresh download check");     }      String tmapperdbPath, tmapperlgPath, tmapperMD5Path;      String dPath, dmapperdbPath, dmapperlgPath, dmapperMD5Path;      private void setup() throws Exception {         File tempDir = File.createTempFile("test", "zip");         tempDir.delete();         tempDir.mkdir();         tempDir.deleteOnExit();         MapLoader ml = new MapLoader(new JDBMMapper(tempDir.getAbsolutePath() + File.separator + "mapper"));         StringBuffer sb = new StringBuffer();         sb.append("47.6636333\\t-122.3083683\\tlambda\\t004005b45c85\\n");         sb.append("47.6636333\\t-122.3083683\\tlinksys\\t000c41424432\\n");         sb.append("47.6637783\\t-122.30837\\t4714\\t00095b5322ec\\n");         InputStream is = new ByteArrayInputStream(sb.toString().getBytes());         ml.loadMap(is);         is.close();         tmapperdbPath = ((JDBMMapper) ml.getMapper()).getDbName() + ".db";         tmapperlgPath = ((JDBMMapper) ml.getMapper()).getDbName() + ".lg";         tmapperMD5Path = ((JDBMMapper) ml.getMapper()).getDbName() + ".md5";         String md5sum = FileSynchronizer.loadFileHash(tmapperdbPath);         PrintWriter p = new PrintWriter(new BufferedOutputStream(new FileOutputStream(tmapperMD5Path)));         p.println(md5sum);         p.close();         File tempZip = File.createTempFile("mappertmp", "zip");         ZipUtil.dirToZip(tempDir, tempZip);         Hashtable files = new Hashtable();         files.put("mapper-zip.php", tempZip.getAbsolutePath());         files.put("mapper-md5.php", tmapperMD5Path);         FileVend vend = new FileVend(files);         vend.register();         ProxyServletEngine.startProxy(true);         File dFile = File.createTempFile("test_download", "");         dFile.delete();         dFile.mkdir();         dFile.deleteOnExit();         dPath = dFile.getAbsolutePath();     }"""
line="""package com.hp.hpl.jena.xmloutput.test;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Random; import java.util.Vector; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import com.hp.hpl.jena.rdf.model.Model; import com.hp.hpl.jena.rdf.model.Property; import com.hp.hpl.jena.rdf.model.RDFErrorHandler; import com.hp.hpl.jena.rdf.model.RDFNode; import com.hp.hpl.jena.rdf.model.RDFReader; import com.hp.hpl.jena.rdf.model.RDFWriter; import com.hp.hpl.jena.rdf.model.Resource; import com.hp.hpl.jena.rdf.model.Statement; import com.hp.hpl.jena.rdf.model.StmtIterator; import com.hp.hpl.jena.rdf.model.test.ModelTestBase; import com.hp.hpl.jena.shared.JenaException; import com.hp.hpl.jena.vocabulary.DAML_OIL; import com.hp.hpl.jena.vocabulary.RDFSyntax;   public class testWriterAndReader extends ModelTestBase implements RDFErrorHandler {      private static boolean showProgress = false;      private static int firstTest = 4;      private static int lastTest = 9;      private static int repetitionsJ = 6;      protected static Log logger = LogFactory.getLog(testWriterAndReader.class);      String lang;      String test;      int fileNumber;      int options = 0;      testWriterAndReader(String name, String lang, int fName) {         super(name);         this.lang = lang;         this.fileNumber = fName;     }      testWriterAndReader(String name, String lang, int fName, int options) {         super(name);         this.lang = lang;         this.fileNumber = fName;         this.options = options;     }      public String toString() {         return getName() + " " + lang + " t" + fileNumber + "000.rdf" + (options != 0 ? ("[" + options + "]") : "");     }      static Test suite(String lang) {         return suite(lang, false);     }      public static Test suite() {         return suite("special");     }      private static boolean nBits(int i, int ok[]) {         int cnt = 0;         while (i > 0) {             if ((i & 1) == 1) cnt++;             i >>= 1;         }         for (int j = 0; j < ok.length; j++) if (cnt == ok[j]) return true;         return false;     }      static Test suite(String lang, boolean lots) {         TestSuite langsuite = new TestSuite();         langsuite.setName(lang);         if (lang.equals("special")) {             langsuite.addTest(new TestXMLFeatures("testNoReification", "RDF/XML-ABBREV"));             return langsuite;         }         langsuite.addTest(new testWriterInterface("testWriting", lang));         langsuite.addTest(new testWriterInterface("testLineSeparator", lang));         for (int k = firstTest; k <= lastTest; k++) {             if (lang.indexOf("XML") > 0) {                 langsuite.addTest(new testWriterAndReader("testLongId", lang, k));                 for (int j = 1; j < (lang.equals("RDF/XML-ABBREV") ? (1 << blockRules.length) : 2); j++) {                     if (lots || nBits(j, new int[] { 1, 6, 7 })) langsuite.addTest(new testWriterAndReader("testOptions " + k + " " + j, lang, k, j) {                          public void runTest() throws IOException {                             testOptions();                         }                     });                 }             }         }         if (lang.indexOf("XML") > 0) {             langsuite.addTest(new TestXMLFeatures("testBadURIAsProperty1", lang));             langsuite.addTest(new TestXMLFeatures("testBadURIAsProperty2", lang));             langsuite.addTest(new TestXMLFeatures("testBadProperty1", lang));             langsuite.addTest(new TestXMLFeatures("testLiAsProperty1", lang));             langsuite.addTest(new TestXMLFeatures("testDescriptionAsProperty", lang));             langsuite.addTest(new TestXMLFeatures("testXMLBase", lang));             langsuite.addTest(new TestXMLFeatures("testRelativeAPI", lang));             langsuite.addTest(new TestXMLFeatures("testRelative", lang));             langsuite.addTest(new TestXMLFeatures("testBug696057", lang));             langsuite.addTest(new TestXMLFeatures("testPropertyURI", lang));             langsuite.addTest(new TestXMLFeatures("testUseNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testUseDefaultNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testUseUnusedNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testBadPrefixNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testRDFNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicatePrefixSysPropAndExplicit", lang));             langsuite.addTest(new TestXMLFeatures("testRDFDefaultNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicateNamespace", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicatePrefix", lang));             langsuite.addTest(new TestXMLFeatures("testUseNamespaceSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testDefaultNamespaceSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicateNamespaceSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testDuplicatePrefixSysProp", lang));             langsuite.addTest(new TestXMLFeatures("testUTF8DeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testUTF16DeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testUTF8DeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testUTF16DeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testISO8859_1_DeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testISO8859_1_DeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testStringDeclAbsent", lang));             langsuite.addTest(new TestXMLFeatures("testStringDeclPresent", lang));             langsuite.addTest(new TestXMLFeatures("testTab", lang));             langsuite.addTest(new TestXMLFeatures("testNoLiteral", lang));             langsuite.addTest(new TestXMLFeatures("testNoTab", lang));             langsuite.addTest(new TestXMLFeatures("testDoubleQuote", lang));             langsuite.addTest(new TestXMLFeatures("testSingleQuote", lang));             langsuite.addTest(new TestXMLFeatures("testNullBaseWithAbbrev", lang));         }         if (lang.equals("RDF/XML-ABBREV")) {             langsuite.addTest(new TestXMLFeatures("testNoPropAttr", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoDamlCollection", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoRdfCollection", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoLi", "RDF/XML-ABBREV"));             langsuite.addTest(new TestXMLFeatures("testNoID", lang));             langsuite.addTest(new TestXMLFeatures("testNoID2", lang));             langsuite.addTest(new TestXMLFeatures("testNoResource", lang));             langsuite.addTest(new TestXMLFeatures("testNoReification", lang));             langsuite.addTest(new TestXMLFeatures("testNoPropAttrs", lang));             langsuite.addTest(new TestXMLFeatures("testNoCookUp", lang));             langsuite.addTest(new TestXMLFeatures("testPropAttrs", lang));         }         return langsuite;     }      public void testRandom() throws IOException {         doTest(new String[] {}, new Object[] {});     }      public void testLongId() throws IOException {         doTest(new String[] { "longId" }, new Object[] { new Boolean(true) });     }      static Resource blockRules[] = { RDFSyntax.parseTypeLiteralPropertyElt, RDFSyntax.parseTypeCollectionPropertyElt, RDFSyntax.propertyAttr, RDFSyntax.sectionReification, RDFSyntax.sectionListExpand, RDFSyntax.parseTypeResourcePropertyElt, DAML_OIL.collection };      public void testOptions() throws IOException {         Vector v = new Vector();         for (int i = 0; i < blockRules.length; i++) {             if ((options & (1 << i)) != 0) v.add(blockRules[i]);         }         Resource blocked[] = new Resource[v.size()];         v.copyInto(blocked);         doTest(new String[] { "blockRules" }, new Object[] { blocked });     }      public void doTest(String[] propNames, Object[] propVals) throws IOException {         test(lang, 35, 1, propNames, propVals);     }      static final String baseUris[] = { "http://foo.com/Hello", "http://foo.com/Hello", "http://daml.umbc.edu/ontologies/calendar-ont", "http://www.daml.org/2001/03/daml+oil-ex" };      ByteArrayOutputStream tmpOut;           public void test(String rwLang, int seed, int jjjMax, String[] wopName, Object[] wopVal) throws IOException {         Model m1 = createMemModel();         Model m2 = createMemModel();         test = "testWriterAndReader lang=" + rwLang + " seed=" + seed;         String filebase = "testing/regression/testWriterAndReader/";         if (showProgress) System.out.println("Beginning " + test);         Random random = new Random(seed);         RDFReader rdfRdr = m1.getReader(rwLang);         RDFWriter rdfWtr = m1.getWriter(rwLang);         if (wopName != null) {             for (int i = 0; i < wopName.length; i++) {                 rdfWtr.setProperty(wopName[i], wopVal[i]);             }         }         rdfRdr.setErrorHandler(this);         rdfWtr.setErrorHandler(this);         for (int jjj = 0; jjj < jjjMax; jjj++) {             String fileName = "t" + (fileNumber * 1000) + ".rdf";             m1 = createMemModel();             String baseUriRead;             if (fileNumber < baseUris.length) baseUriRead = baseUris[fileNumber]; else baseUriRead = "http://foo.com/Hello";             InputStream rdr = new FileInputStream(filebase + fileName);             m1.read(rdr, baseUriRead);             rdr.close();             for (int j = 0; j < repetitionsJ; j++) {                 String baseUriWrite = j % 2 == 0 ? baseUriRead : "http://bar.com/irrelevant";                 int cn = (int) m1.size();                 if ((j % 2) == 0 && j > 0) prune(m1, random, 1 + cn / 10);                 if ((j % 2) == 0 && j > 0) expand(m1, random, 1 + cn / 10);                 tmpOut = new ByteArrayOutputStream();                 rdfWtr.write(m1, tmpOut, baseUriWrite);                 tmpOut.flush();                 tmpOut.close();                 m2 = createMemModel();                 InputStream in = new ByteArrayInputStream(tmpOut.toByteArray());                 rdfRdr.read(m2, in, baseUriWrite);                 in.close();                 Model s1 = m1;                 Model s2 = m2;                 assertTrue("Comparison of file written out, and file read in.", s1.isIsomorphicWith(s2));                 tmpOut.reset();                 tmpOut = null;             }             if (showProgress) {                 System.out.print("+");                 System.out.flush();             }         }         if (showProgress) System.out.println("End of " + test);     }      static boolean linuxFileDeleteErrorFlag = false;           private void prune(Model m, Random random, int cnt) {         Statement die[] = new Statement[cnt];         int sz = (int) m.size();         StmtIterator ss = m.listStatements();         try {             for (int i = 0; i < cnt; i++) die[i] = ss.nextStatement();             while (ss.hasNext()) {                 int ix = random.nextInt(sz);                 if (ix < cnt) die[ix] = ss.nextStatement();             }         } finally {             ss.close();         }         for (int i = 0; i < cnt; i++) m.remove(die[i]);     }           private void expand(Model m, Random random, int cnt) {         Resource subject[] = new Resource[cnt];         Property predicate[] = new Property[cnt];         RDFNode object[] = new RDFNode[cnt];         int sz = (int) m.size();         StmtIterator ss = m.listStatements();         try {             for (int i = 0; i < cnt; i++) {                 Statement s = ss.nextStatement();                 subject[i] = s.getSubject();                 predicate[i] = s.getPredicate();                 object[i] = s.getObject();             }             while (ss.hasNext()) {                 Statement s = ss.nextStatement();                 Resource subj = s.getSubject();                 RDFNode obj = s.getObject();                 int ix = random.nextInt(sz);                 if (ix < cnt) subject[ix] = subj;                 ix = random.nextInt(sz);                 if (ix < cnt) object[ix] = subj;                 ix = random.nextInt(sz);                 if (ix < cnt) predicate[ix] = s.getPredicate();                 ix = random.nextInt(sz);                 if (ix < cnt) object[ix] = obj;                 if (obj instanceof Resource) {                     ix = random.nextInt(sz);                     if (ix < cnt) subject[ix] = (Resource) obj;                 }             }         } finally {             ss.close();         }         for (int i = 0; i < cnt; i++) m.add(subject[i], predicate[i], object[i]);     }           public void warning(Exception e) {         System.out.println(new String(tmpOut.toString()));         throw new JenaException(e);     }      public void error(Exception e) {         fail(e.getMessage());     }      public void fatalError(Exception e) {         error(e);         throw new JenaException(e);     } """
#line="""package com.google.zxing.client.android;  import java.io.ByteArrayOutputStream; import java.io.IOException; import java.net.URI; import java.util.ArrayList; import java.util.List; import org.apache.http.Header; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpHead; import org.apache.http.client.methods.HttpUriRequest; import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import android.app.Activity; import android.content.Intent; import android.content.res.Configuration; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.util.Log; import android.view.KeyEvent; import android.view.LayoutInflater; import android.view.View; import android.webkit.CookieManager; import android.webkit.CookieSyncManager; import android.widget.Button; import android.widget.EditText; import android.widget.ListView; import android.widget.TextView;  public final class SearchBookContentsActivity extends Activity {      private static final String TAG = "SearchBookContents";      private static final String USER_AGENT = "ZXing/1.3 (Android)";      private NetworkThread mNetworkThread;      private String mISBN;      private EditText mQueryTextView;      private Button mQueryButton;      private ListView mResultListView;      private TextView mHeaderView;      @Override     public void onCreate(Bundle icicle) {         super.onCreate(icicle);         CookieSyncManager.createInstance(this);         CookieManager.getInstance().removeExpiredCookie();         Intent intent = getIntent();         if (intent == null || (!intent.getAction().equals(Intents.SearchBookContents.ACTION) && !intent.getAction().equals(Intents.SearchBookContents.DEPRECATED_ACTION))) {             finish();             return;         }         mISBN = intent.getStringExtra(Intents.SearchBookContents.ISBN);         setTitle(getString(R.string.sbc_name) + ": ISBN " + mISBN);         setContentView(R.layout.search_book_contents);         mQueryTextView = (EditText) findViewById(R.id.query_text_view);         String initialQuery = intent.getStringExtra(Intents.SearchBookContents.QUERY);         if (initialQuery != null && initialQuery.length() > 0) {             mQueryTextView.setText(initialQuery);         }         mQueryTextView.setOnKeyListener(mKeyListener);         mQueryButton = (Button) findViewById(R.id.query_button);         mQueryButton.setOnClickListener(mButtonListener);         mResultListView = (ListView) findViewById(R.id.result_list_view);         LayoutInflater factory = LayoutInflater.from(this);         mHeaderView = (TextView) factory.inflate(R.layout.search_book_contents_header, mResultListView, false);         mResultListView.addHeaderView(mHeaderView);     }      @Override     protected void onResume() {         super.onResume();         mQueryTextView.selectAll();     }      @Override     public void onConfigurationChanged(Configuration config) {         super.onConfigurationChanged(config);     }      public final Handler mHandler = new Handler() {          @Override         public void handleMessage(Message message) {             switch(message.what) {                 case R.id.search_book_contents_succeeded:                     handleSearchResults((JSONObject) message.obj);                     resetForNewQuery();                     break;                 case R.id.search_book_contents_failed:                     resetForNewQuery();                     mHeaderView.setText(R.string.msg_sbc_failed);                     break;             }         }     };      private void resetForNewQuery() {         mNetworkThread = null;         mQueryTextView.setEnabled(true);         mQueryTextView.selectAll();         mQueryButton.setEnabled(true);     }      private final Button.OnClickListener mButtonListener = new Button.OnClickListener() {          public void onClick(View view) {             launchSearch();         }     };      private final View.OnKeyListener mKeyListener = new View.OnKeyListener() {          public boolean onKey(View view, int keyCode, KeyEvent event) {             if (keyCode == KeyEvent.KEYCODE_ENTER) {                 launchSearch();                 return true;             }             return false;         }     };      private void launchSearch() {         if (mNetworkThread == null) {             String query = mQueryTextView.getText().toString();             if (query != null && query.length() > 0) {                 mNetworkThread = new NetworkThread(mISBN, query, mHandler);                 mNetworkThread.start();                 mHeaderView.setText(R.string.msg_sbc_searching_book);                 mResultListView.setAdapter(null);                 mQueryTextView.setEnabled(false);                 mQueryButton.setEnabled(false);             }         }     }      private void handleSearchResults(JSONObject json) {         try {             int count = json.getInt("number_of_results");             mHeaderView.setText("Found " + ((count == 1) ? "1 result" : count + " results"));             if (count > 0) {                 JSONArray results = json.getJSONArray("search_results");                 SearchBookContentsResult.setQuery(mQueryTextView.getText().toString());                 List<SearchBookContentsResult> items = new ArrayList<SearchBookContentsResult>(count);                 for (int x = 0; x < count; x++) {                     items.add(parseResult(results.getJSONObject(x)));                 }                 mResultListView.setAdapter(new SearchBookContentsAdapter(this, items));             } else {                 String searchable = json.optString("searchable");                 if (searchable != null && searchable.equals("false")) {                     mHeaderView.setText(R.string.msg_sbc_book_not_searchable);                 }                 mResultListView.setAdapter(null);             }         } catch (JSONException e) {             Log.e(TAG, e.toString());             mResultListView.setAdapter(null);             mHeaderView.setText(R.string.msg_sbc_failed);         }     }      private SearchBookContentsResult parseResult(JSONObject json) {         try {             String pageNumber = json.getString("page_number");             if (pageNumber.length() > 0) {                 pageNumber = getString(R.string.msg_sbc_page) + ' ' + pageNumber;             } else {                 pageNumber = getString(R.string.msg_sbc_unknown_page);             }             String snippet = json.optString("snippet_text");             boolean valid = true;             if (snippet.length() > 0) {                 snippet = snippet.replaceAll("\\<.*?\\>", "");                 snippet = snippet.replaceAll("&lt;", "<");                 snippet = snippet.replaceAll("&gt;", ">");                 snippet = snippet.replaceAll("&#39;", "'");                 snippet = snippet.replaceAll("&quot;", "\"");             } else {                 snippet = '(' + getString(R.string.msg_sbc_snippet_unavailable) + ')';                 valid = false;             }             return new SearchBookContentsResult(pageNumber, snippet, valid);         } catch (JSONException e) {             return new SearchBookContentsResult(getString(R.string.msg_sbc_no_page_returned), "", false);         }     }      private static final class NetworkThread extends Thread {          private final String mISBN;          private final String mQuery;          private final Handler mHandler;          NetworkThread(String isbn, String query, Handler handler) {             mISBN = isbn;             mQuery = query;             mHandler = handler;         }          @Override         public void run() {             AndroidHttpClient client = null;             try {                 URI uri = new URI("http", null, "www.google.com", -1, "/books", "vid=isbn" + mISBN + "&jscmd=SearchWithinVolume2&q=" + mQuery, null);                 HttpUriRequest get = new HttpGet(uri);                 get.setHeader("cookie", getCookie(uri.toString()));                 client = AndroidHttpClient.newInstance(USER_AGENT);                 HttpResponse response = client.execute(get);                 if (response.getStatusLine().getStatusCode() == 200) {                     HttpEntity entity = response.getEntity();                     ByteArrayOutputStream jsonHolder = new ByteArrayOutputStream();                     entity.writeTo(jsonHolder);                     jsonHolder.flush();                     JSONObject json = new JSONObject(jsonHolder.toString(getEncoding(entity)));                     jsonHolder.close();                     Message message = Message.obtain(mHandler, R.id.search_book_contents_succeeded);                     message.obj = json;                     message.sendToTarget();                 } else {                     Log.e(TAG, "HTTP returned " + response.getStatusLine().getStatusCode() + " for " + uri);                     Message message = Message.obtain(mHandler, R.id.search_book_contents_failed);                     message.sendToTarget();                 }             } catch (Exception e) {                 Log.e(TAG, e.toString());                 Message message = Message.obtain(mHandler, R.id.search_book_contents_failed);                 message.sendToTarget();             } finally {                 if (client != null) {                     client.close();                 }             }         }          private String getCookie(String url) {             String cookie = CookieManager.getInstance().getCookie(url);             if (cookie == null || cookie.length() == 0) {                 Log.v(TAG, "Book Search cookie was missing or expired");                 HttpUriRequest head = new HttpHead(url);                 AndroidHttpClient client = AndroidHttpClient.newInstance(USER_AGENT);                 try {                     HttpResponse response = client.execute(head);                     if (response.getStatusLine().getStatusCode() == 200) {                         Header[] cookies = response.getHeaders("set-cookie");                         for (int x = 0; x < cookies.length; x++) {                             CookieManager.getInstance().setCookie(url, cookies[x].getValue());                         }                         CookieSyncManager.getInstance().sync();                         cookie = CookieManager.getInstance().getCookie(url);                     }                 } catch (IOException e) {                     Log.e(TAG, e.toString());                 }                 client.close();             }             return cookie;         }          private static String getEncoding(HttpEntity entity) {             return "windows-1252";         }     } }"""
#line="""package net.sf.daileon;  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream;   class DirectoryDuplicator {           static void copyDirectory(File sourceLocation, File targetLocation) {         if (sourceLocation.isDirectory()) {             if (!targetLocation.exists()) {                 if (!targetLocation.mkdir()) {                     String message = "It was not possible to create directory " + targetLocation.getAbsolutePath() + ". This application cannot continue.";                     throw new RuntimeException(message);                 }             }             String[] children = sourceLocation.list();             for (int i = 0; i < children.length; i++) {                 copyDirectory(new File(sourceLocation, children[i]), new File(targetLocation, children[i]));             }         } else {             try {                 InputStream in = new FileInputStream(sourceLocation);                 OutputStream out = new FileOutputStream(targetLocation);                 byte[] buf = new byte[1024];                 int len;                 while ((len = in.read(buf)) > 0) {                     out.write(buf, 0, len);                 }                 in.close();                 out.close();             } catch (IOException exception) {                 String message = "It was not possible to copy the source directory " + "to the chosen destiny due to the following cause: " + exception.getMessage();                 throw new RuntimeException(message, exception);             }         }     } } """
# def walk(tree):
#     if not tree.getChildCount():
#         return tree
#     return tree.getChildren()

def remove_comments(text):
    """Remove C-style /*comments*/ from a string."""
    p = r'/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|\'(\\.|[^\'\\])*\'|.[^/"\'\\]*)'
    return ''.join(m.group(2) for m in re.finditer(p, text, re.M | re.S) if m.group(2))
def main():
    # stream = InputStream(line.decode('utf-8', 'ignore'))
    # lexer = JavaLexer(stream)
    # toks = CommonTokenStream(lexer)
    # parser = JavaParser(toks)
    #
    # tree = parser.compilationUnit()#.compilationUnit()

    # stream = InputStream(input_s)
    # lexer = Python2Lexer(stream)
    # toks = CommonTokenStream(lexer)
    # # toks.fetch(500)
    # # print "stream: ", stream
    # # for tok in toks.tokens:
    # #     print tok
    # parser = Python2Parser(toks)
    #
    # tree = parser.file_input()#.compilationUnit()#.compilationUnit()
    # print tree.getText()
    # print type(tree)
    # walk(tree)
    tokens = list(javalang.tokenizer.tokenize(line))
    tree = javalang.parse.parse(remove_comments(line))
    print( tree.getChildCount())
    # for t in tree.getChildren():
    #     # print t
    #     print t.getChildCount()

    # printer = HelloPrintListener()
    # walker = ParseTreeWalker()
    # walker.walk(HelloPrintListener(), tree)
    # print 'test'
if __name__ == '__main__':
    main()

#sys.exit()
#
# import plyj.parser as plyj
# import sys
# parser = plyj.Parser()
# # parse a compilation unit from a string
# tree = parser.parse_string('System.out.println("Hello " + "world");')
# print tree
#
#sys.exit()

# from .ast import Node
# tree = javalang.parse.parse('System.out.println("Hello " + "world");')
tokens = javalang.tokenizer.tokenize(line)
print (tokens)
parser = javalang.parser.Parser(tokens)
tree = parser.parse_class_body()
# print list(tokens)
# parser = javalang.parser.Parser(tokens)
# tree = javalang.tree(parser)
# for p, n in javalang.ast.walk_tree(tree):
#     print p, n, n.position
#
for  node in tree:
    print  (node)
    # isleaf = True
    # for child in node.children:
    #     if isinstance(child, javalang.ast.Node):
    #         isleaf = False
    #         break
    # if isleaf:
    #     print  node
    #     print node.children

    # try:
    #     print node.name
    # except:
    #     pass
